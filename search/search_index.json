{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pitfall Pygame Documentation To run the game, you need to have python 3 and the dependencies listed in the requirements.txt file installed. Command to install dependencies: pip install -r requirements.txt Command to run the game: python3 Pitfall.py Files On the src folder, you can find the following directories and files: Fontes : Contains the necessary files to import the game's fonts. Imagens : Contains the necessary files to import the game's sprites. Sons : Contains the necessary files to import the game's sounds. Pitfall.py This is the main file of the game. It contains the main loop and the game's initialization, as well dealing with events that kill the program and eventual crashes and errors. Configuracoes.py This file contains the game's configurations, such as the screen's size, FPS, colors saved as constants, and manages the imports fo the the game's fonts, sounds and sprites as well as defining the initial state of the states machine for the game. Classes.py This defines the following classes: Player This class creates the player object. It has two methods: init and update. The init method loads the player's sprites and defines the shape for the colider. The update method is responsible for the player's movement, and for checking if the player has collided with an obstacle or a hole. If the player has collided with an obstacle, it loses a life and the obstacle is reset to the beginning of the screen. If the player has collided with a hole, it loses a life and the hole is reset to the beginning of the screen. Also inside the update method is the code to check if is time to change the player's image, and if it is, it changes it. No methods return anything. BARRIL This class creates the obstacles objects that the player must avoid. It has two methods: init and update. The init method loads the obstacle asset and defines the shape for the colider. The update method is responsible for the movement of the obstacle and for checking if it has reached the end of the screen, and if it has, it resets the obstacle to the beginning of the screen. Also inside the update method is the code to check if is time to change the obstacle's image, and if it is, it changes it. No methods return anything. UNIC This class works basicly the same as the BARRIL class, but it creates the obstacles with a random Y position and a different set os sprites. HOLE This class creates the holes objects that the player must jump over. It has two methods: init and update. The init method loads the hole asset and defines the shape for the colider. The update method is empty, since nether the position or the sprite changes, but is is necessary for the class to work because of the superclass. No methods return anything. Premio This class creates the collectables objects that the player can collect to gain points. It has two methods: init and update. The init method treasure asset and defines the shape for the colider. The update method is empty, but is is necessary for the class to work because of the superclass. No methods return anything. LIVES This class defines the markers for the live count for the player. It has two methods: init and update. The init method loads the initial live count (3) and the heart icon. The update method is empty, but is is necessary for the class to work because of the superclass. No methods return anything. PREMIO This class controls the game's score marker (it is not responsible for the points count, just to display it). It has two methods: init and update. The init method loads the initial score (0) and the treasure icon. The update method is empty, but is is necessary for the class to work because of the superclass. No methods return anything. Back This class controls the background of the game. It has two methods: init and update. The init method loads the first background image and scales it to the screen's size. The update method is called every frame, and it checks if the time to change the image has been reached, and if it has, it loads the next image and scales it to the screen's size. No methods return anything. load_assets This method loads the game's assets, by creating a dictionary with the sprites necessaries for objects from the classes above, and returns it. For assets that require animations on screen, the code creates a secondary list, with one object with each frame of the animation, and then adds it to the dictionary. def load_assets(img_dir, snd_dir, fnt_dir): assets = {} ... return assets Tela.py Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#pitfall","text":"","title":"Pitfall"},{"location":"#pygame-documentation","text":"To run the game, you need to have python 3 and the dependencies listed in the requirements.txt file installed. Command to install dependencies: pip install -r requirements.txt Command to run the game: python3 Pitfall.py","title":"Pygame Documentation"},{"location":"#files","text":"On the src folder, you can find the following directories and files: Fontes : Contains the necessary files to import the game's fonts. Imagens : Contains the necessary files to import the game's sprites. Sons : Contains the necessary files to import the game's sounds.","title":"Files"},{"location":"#pitfallpy","text":"This is the main file of the game. It contains the main loop and the game's initialization, as well dealing with events that kill the program and eventual crashes and errors.","title":"Pitfall.py"},{"location":"#configuracoespy","text":"This file contains the game's configurations, such as the screen's size, FPS, colors saved as constants, and manages the imports fo the the game's fonts, sounds and sprites as well as defining the initial state of the states machine for the game.","title":"Configuracoes.py"},{"location":"#classespy","text":"This defines the following classes: Player This class creates the player object. It has two methods: init and update. The init method loads the player's sprites and defines the shape for the colider. The update method is responsible for the player's movement, and for checking if the player has collided with an obstacle or a hole. If the player has collided with an obstacle, it loses a life and the obstacle is reset to the beginning of the screen. If the player has collided with a hole, it loses a life and the hole is reset to the beginning of the screen. Also inside the update method is the code to check if is time to change the player's image, and if it is, it changes it. No methods return anything. BARRIL This class creates the obstacles objects that the player must avoid. It has two methods: init and update. The init method loads the obstacle asset and defines the shape for the colider. The update method is responsible for the movement of the obstacle and for checking if it has reached the end of the screen, and if it has, it resets the obstacle to the beginning of the screen. Also inside the update method is the code to check if is time to change the obstacle's image, and if it is, it changes it. No methods return anything. UNIC This class works basicly the same as the BARRIL class, but it creates the obstacles with a random Y position and a different set os sprites. HOLE This class creates the holes objects that the player must jump over. It has two methods: init and update. The init method loads the hole asset and defines the shape for the colider. The update method is empty, since nether the position or the sprite changes, but is is necessary for the class to work because of the superclass. No methods return anything. Premio This class creates the collectables objects that the player can collect to gain points. It has two methods: init and update. The init method treasure asset and defines the shape for the colider. The update method is empty, but is is necessary for the class to work because of the superclass. No methods return anything. LIVES This class defines the markers for the live count for the player. It has two methods: init and update. The init method loads the initial live count (3) and the heart icon. The update method is empty, but is is necessary for the class to work because of the superclass. No methods return anything. PREMIO This class controls the game's score marker (it is not responsible for the points count, just to display it). It has two methods: init and update. The init method loads the initial score (0) and the treasure icon. The update method is empty, but is is necessary for the class to work because of the superclass. No methods return anything. Back This class controls the background of the game. It has two methods: init and update. The init method loads the first background image and scales it to the screen's size. The update method is called every frame, and it checks if the time to change the image has been reached, and if it has, it loads the next image and scales it to the screen's size. No methods return anything. load_assets This method loads the game's assets, by creating a dictionary with the sprites necessaries for objects from the classes above, and returns it. For assets that require animations on screen, the code creates a secondary list, with one object with each frame of the animation, and then adds it to the dictionary. def load_assets(img_dir, snd_dir, fnt_dir): assets = {} ... return assets","title":"Classes.py"},{"location":"#telapy","text":"","title":"Tela.py"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"}]}